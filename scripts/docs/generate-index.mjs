#!/usr/bin/env node

import { promises as fs } from "fs";
import { dirname, resolve } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const rootDir = resolve(__dirname, "..", "..");
const docsDir = resolve(rootDir, "docs");
const outputPath = resolve(docsDir, "indices", "DOCUMENTATION_INDEX.md");

const args = new Set(process.argv.slice(2));
const checkMode = args.has("--check");

const ignoreFiles = new Set(["DOCUMENTATION_INDEX.md".toLowerCase()]);

const ignoreDirs = new Set([".git", ".github"]);

function toTitleCase(segment) {
  if (!segment) return segment;
  return segment
    .split(/[\s-_]+/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
}

async function collectDocs(dir, relative = "") {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const docs = [];

  for (const entry of entries) {
    if (entry.name.startsWith(".")) continue;
    if (ignoreDirs.has(entry.name)) continue;

    const entryPath = resolve(dir, entry.name);
    const entryRel = relative ? `${relative}/${entry.name}` : entry.name;

    if (entry.isDirectory()) {
      const childDocs = await collectDocs(entryPath, entryRel);
      docs.push(...childDocs);
      continue;
    }

    if (!entry.name.endsWith(".md")) continue;

    if (
      ignoreFiles.has(entry.name.toLowerCase()) &&
      entryRel === "indices/DOCUMENTATION_INDEX.md"
    ) {
      // Skip the file we are about to generate to avoid recursion
      continue;
    }

    const { title, summary } = await extractMetadata(entryPath);
    docs.push({ relative: entryRel.replace(/\\/g, "/"), title, summary });
  }

  return docs;
}

async function extractMetadata(filePath) {
  try {
    const content = await fs.readFile(filePath, "utf8");
    const lines = content.split(/\r?\n/);

    let title = filePath.split(/[/\\]/).pop().replace(/\.md$/i, "");
    let summary = "";
    let foundHeading = false;

    for (const raw of lines) {
      const line = raw.trim();
      if (!foundHeading && line.startsWith("#")) {
        title = line.replace(/^#+\s*/, "").trim() || title;
        foundHeading = true;
        continue;
      }
      if (!foundHeading) {
        continue;
      }
      if (!line) continue;
      if (line.startsWith("#")) continue;
      if (line.startsWith("```")) continue;
      if (line.startsWith("<!--")) continue;
      if (line.startsWith("---")) continue;
      if (line.startsWith("***")) continue;
      if (line.startsWith(">")) continue;
      if (line.startsWith("- ")) continue;
      if (line.startsWith("* ")) continue;
      if (line.startsWith("[")) continue;
      if (line.startsWith("{")) continue;
      if (line.startsWith("./")) continue;
      if (!/[a-zA-Z]/.test(line)) continue;
      summary = line.replace(/[*`_~]/g, "").trim();
      if (summary) {
        break;
      }
    }

    if (summary.length > 140) {
      summary = `${summary.slice(0, 137).trim()}...`;
    }

    return { title, summary };
  } catch (error) {
    return { title: filePath.split(/[/\\]/).pop(), summary: "" };
  }
}

function buildIndex(docs) {
  const sections = new Map();

  for (const doc of docs) {
    const [firstSegment, ...rest] = doc.relative.split("/");
    const sectionKey = rest.length ? firstSegment : "Top-level";
    if (!sections.has(sectionKey)) {
      sections.set(sectionKey, []);
    }
    sections.get(sectionKey).push(doc);
  }

  const sortedSections = Array.from(sections.entries()).sort(([a], [b]) => {
    if (a === "Top-level") return -1;
    if (b === "Top-level") return 1;
    return a.localeCompare(b);
  });
  const timestamp = new Date().toISOString();
  let output = "# Documentation Index\n\n";
  output += `**Generated:** ${timestamp}`;
  output += "\n\n";

  for (const [section, entries] of sortedSections) {
    const title =
      section === "Top-level" ? "Top-level Documents" : toTitleCase(section);
    output += `## ${title}\n\n`;

    const sortedEntries = entries.sort((a, b) =>
      a.title.localeCompare(b.title)
    );
    for (const entry of sortedEntries) {
      const summary = entry.summary ? ` ‚Äî ${entry.summary}` : "";
      output += `- [${entry.title}](${entry.relative})${summary}\n`;
    }
    output += "\n";
  }

  output += "\n---\n\n";
  output +=
    "‚ú® This index is generated by `scripts/docs/generate-index.mjs`. Run `task docs:update` to refresh.";
  output += "\n";

  return output;
}

async function ensureDirectory(pathname) {
  const parent = dirname(pathname);
  await fs.mkdir(parent, { recursive: true });
}

async function main() {
  const docs = await collectDocs(docsDir);
  const content = buildIndex(docs);

  if (checkMode) {
    try {
      const existing = await fs.readFile(outputPath, "utf8");
      const normalise = (value) =>
        value
          .replace(/\r/g, "")
          .replace(/^\*\*Generated:.*$/m, "**Generated:** <normalized>");

      if (normalise(existing).trim() === normalise(content).trim()) {
        console.log("‚úÖ Documentation index is up to date.");
        return;
      }
      console.error(
        "‚ùå Documentation index is stale. Run `task docs:update` to regenerate."
      );
      process.exitCode = 1;
      return;
    } catch (error) {
      if (error.code === "ENOENT") {
        console.error(
          "‚ùå Documentation index is missing. Run `task docs:update` to generate."
        );
      } else {
        console.error(
          "‚ùå Failed to read existing documentation index:",
          error.message
        );
      }
      process.exitCode = 1;
      return;
    }
  }

  await ensureDirectory(outputPath);
  await fs.writeFile(outputPath, content, "utf8");
  console.log(
    `üìù Wrote documentation index to ${outputPath.replace(rootDir + "/", "")}`
  );
}

await main();
