name: Intelligent Deploy to Droplet

on:
  push:
    branches: [main]
    paths:
      - "agent_*/**"
      - "shared/**"
      - "config/**"
      - "deploy/docker-compose.yml"
      - ".github/workflows/deploy-intelligent.yml"
  workflow_dispatch:
    inputs:
      deploy_type:
        description: "Deployment type"
        required: false
        default: "auto"
        type: choice
        options:
          - auto
          - config
          - full
          - quick

env:
  DROPLET_HOST: root@45.55.173.72
  DEPLOY_PATH: /opt/Dev-Tools
  DROPLET_IP: 45.55.173.72
  HEALTH_CHECK_TIMEOUT: 90
  HEALTH_CHECK_INTERVAL: 5

jobs:
  prepare-env:
    name: Prepare Environment
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create .env file
        run: |
          cp config/env/.env.template config/env/.env
          # Orchestrator API Security
          echo "ORCHESTRATOR_API_KEY=${{ secrets.ORCHESTRATOR_API_KEY }}" >> config/env/.env
          # LLM & Tracing
          echo "GRADIENT_API_KEY=${{ secrets.GRADIENT_API_KEY }}" >> config/env/.env
          echo "LANGCHAIN_API_KEY=${{ secrets.LANGSMITH_API_KEY }}" >> config/env/.env
          echo "LANGSMITH_API_KEY=${{ secrets.LANGSMITH_API_KEY }}" >> config/env/.env
          echo "LANGSMITH_WORKSPACE_ID=${{ secrets.LANGSMITH_WORKSPACE_ID }}" >> config/env/.env
          # OpenRouter (Multi-Model LLM Gateway)
          echo "OPENROUTER_API_KEY=${{ secrets.OPENROUTER_API_KEY }}" >> config/env/.env
          # LLM Provider Keys
          echo "CLAUDE_API_KEY=${{ secrets.CLAUDE_API_KEY }}" >> config/env/.env
          echo "MISTRAL_API_KEY=${{ secrets.MISTRAL_API_KEY }}" >> config/env/.env
          echo "PERPLEXITY_API_KEY=${{ secrets.PERPLEXITY_API_KEY }}" >> config/env/.env
          # Linear Integration
          echo "LINEAR_TEAM_ID=${{ secrets.LINEAR_TEAM_ID }}" >> config/env/.env
          echo "LINEAR_API_KEY=${{ secrets.LINEAR_OAUTH_DEV_TOKEN }}" >> config/env/.env
          echo "LINEAR_OAUTH_DEV_TOKEN=${{ secrets.LINEAR_OAUTH_DEV_TOKEN }}" >> config/env/.env
          echo "LINEAR_WEBHOOK_SIGNING_SECRET=${{ secrets.LINEAR_WEBHOOK_SIGNING_SECRET }}" >> config/env/.env
          # RAG/Qdrant
          echo "QDRANT_URL=${{ secrets.QDRANT_URL }}" >> config/env/.env
          echo "QDRANT_API_KEY=${{ secrets.QDRANT_API_KEY }}" >> config/env/.env
          echo "OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}" >> config/env/.env
          # Database
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> config/env/.env
          # OAuth Configuration (GH_OAUTH_CLIENT_SECRET renamed to avoid GITHUB_ prefix restriction)
          echo "GITHUB_OAUTH_CLIENT_SECRET=${{ secrets.GH_OAUTH_CLIENT_SECRET }}" >> config/env/.env
          echo "OAUTH2_PROXY_CLIENT_ID=${{ secrets.OAUTH2_PROXY_CLIENT_ID }}" >> config/env/.env
          echo "OAUTH2_PROXY_CLIENT_SECRET=${{ secrets.OAUTH2_PROXY_CLIENT_SECRET }}" >> config/env/.env
          echo "OAUTH2_PROXY_COOKIE_SECRET=${{ secrets.OAUTH2_PROXY_COOKIE_SECRET }}" >> config/env/.env
          echo "OAUTH2_PROXY_EMAIL_DOMAINS=*" >> config/env/.env
          # Grafana Cloud
          echo "GRAFANA_CLOUD_API_TOKEN=${{ secrets.GRAFANA_CLOUD_API_TOKEN }}" >> config/env/.env
          # Supabase
          echo "SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" >> config/env/.env
          # HuggingFace (ModelOps)
          echo "HUGGINGFACE_TOKEN=${{ secrets.HUGGINGFACE_TOKEN }}" >> config/env/.env

          # Verify file exists and has content
          ls -la config/env/.env
          wc -l config/env/.env

      - name: Upload .env as artifact
        uses: actions/upload-artifact@v4
        with:
          name: env-file
          path: config/env/.env
          retention-days: 1
          include-hidden-files: true

  detect-changes:
    name: Detect Change Type
    runs-on: ubuntu-latest
    outputs:
      deploy_strategy: ${{ steps.strategy.outputs.strategy }}
      has_code_changes: ${{ steps.classify.outputs.has_code_changes }}
      has_config_changes: ${{ steps.classify.outputs.has_config_changes }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v40
        with:
          files_yaml: |
            code:
              - 'agent_*/**/*.py'
              - 'shared/**/*.py'
              - '**/Dockerfile'
              - '**/requirements.txt'
              - 'deploy/docker-compose.yml'
            config:
              - 'config/env/*.env'
              - 'config/**/*.yaml'
              - 'config/**/*.yml'

      - name: Classify changes
        id: classify
        run: |
          if [ "${{ steps.changed-files.outputs.code_any_changed }}" == "true" ]; then
            echo "has_code_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_code_changes=false" >> $GITHUB_OUTPUT
          fi

          if [ "${{ steps.changed-files.outputs.config_any_changed }}" == "true" ]; then
            echo "has_config_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_config_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine strategy
        id: strategy
        run: |
          # Manual override from workflow_dispatch
          if [ "${{ github.event.inputs.deploy_type }}" != "" ]; then
            echo "strategy=${{ github.event.inputs.deploy_type }}" >> $GITHUB_OUTPUT
            echo "Manual override: ${{ github.event.inputs.deploy_type }}"
            exit 0
          fi

          # Auto-detect based on changes
          if [ "${{ steps.classify.outputs.has_code_changes }}" == "true" ]; then
            echo "strategy=full" >> $GITHUB_OUTPUT
            echo "Code changes detected â†’ FULL rebuild"
          elif [ "${{ steps.classify.outputs.has_config_changes }}" == "true" ]; then
            echo "strategy=config" >> $GITHUB_OUTPUT
            echo "Config-only changes â†’ FAST deployment"
          else
            echo "strategy=quick" >> $GITHUB_OUTPUT
            echo "No critical changes â†’ QUICK restart"
          fi

  deploy-config:
    name: Deploy Config Changes
    runs-on: ubuntu-latest
    needs: [detect-changes, prepare-env]
    if: needs.detect-changes.outputs.deploy_strategy == 'config'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DROPLET_SSH_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${{ env.DROPLET_IP }} >> ~/.ssh/known_hosts

      - name: Download .env from artifact
        uses: actions/download-artifact@v4
        with:
          name: env-file
          path: config/env/

      - name: Upload .env to droplet
        run: |
          scp config/env/.env ${{ env.DROPLET_HOST }}:${{ env.DEPLOY_PATH }}/config/env/.env

      - name: Pull latest code on droplet
        run: |
          ssh ${{ env.DROPLET_HOST }} "cd ${{ env.DEPLOY_PATH }} && git stash && git pull origin main"

      - name: Restart services (down+up to reload env)
        run: |
          ssh ${{ env.DROPLET_HOST }} "cd ${{ env.DEPLOY_PATH }}/deploy && \
            docker compose down --remove-orphans --volumes && \
            docker container prune -f && \
            docker compose up -d && \
            docker image prune -f --filter 'dangling=true'"

      - name: Wait for services and health check
        run: |
          echo "ðŸ” Waiting for services to start (max ${{ env.HEALTH_CHECK_TIMEOUT }}s)..."
          max_attempts=$((${{ env.HEALTH_CHECK_TIMEOUT }} / ${{ env.HEALTH_CHECK_INTERVAL }}))

          for i in $(seq 1 $max_attempts); do
            sleep ${{ env.HEALTH_CHECK_INTERVAL }}
            all_healthy=true
            failed_services=""
            
            for port in 8001 8007 8008 8010; do
              response=$(ssh ${{ env.DROPLET_HOST }} "curl -sf http://localhost:${port}/health 2>/dev/null" || echo "")
              status=$(echo "$response" | jq -r '.status // empty' 2>/dev/null || echo "")
              
              if [ "$status" != "healthy" ] && [ "$status" != "ok" ]; then
                all_healthy=false
                failed_services="${failed_services} ${port}"
              else
                echo "  âœ“ Port ${port}: ${status}"
              fi
            done
            
            if [ "$all_healthy" == "true" ]; then
              echo "âœ… All services healthy after $((i * ${{ env.HEALTH_CHECK_INTERVAL }})) seconds"
              exit 0
            fi
            
            echo "â³ Attempt $i/$max_attempts: Waiting for:$failed_services"
          done

          echo "âŒ Services failed to become healthy within ${{ env.HEALTH_CHECK_TIMEOUT }}s"
          echo "ðŸ“‹ Checking logs..."
          ssh ${{ env.DROPLET_HOST }} "cd ${{ env.DEPLOY_PATH }}/deploy && docker compose logs --tail=50"
          exit 1

  deploy-full:
    name: Deploy with Full Rebuild
    runs-on: ubuntu-latest
    needs: [detect-changes, prepare-env]
    if: needs.detect-changes.outputs.deploy_strategy == 'full'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DROPLET_SSH_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${{ env.DROPLET_IP }} >> ~/.ssh/known_hosts

      - name: Download .env from artifact
        uses: actions/download-artifact@v4
        with:
          name: env-file
          path: config/env/

      - name: Upload .env to droplet
        run: |
          scp config/env/.env ${{ env.DROPLET_HOST }}:${{ env.DEPLOY_PATH }}/config/env/.env

      - name: Pull and rebuild on droplet
        run: |
          ssh ${{ env.DROPLET_HOST }} "cd ${{ env.DEPLOY_PATH }} && \
            git pull origin main && \
            cd deploy && \
            docker compose down --remove-orphans --volumes && \
            docker container prune -f && \
            DOCKER_BUILDKIT=1 docker compose build --build-arg BUILDKIT_INLINE_CACHE=1 && \
            docker compose up -d && \
            docker image prune -af --filter 'until=24h' && \
            docker builder prune -af --filter 'until=24h'"

      - name: Wait for services and health check
        run: |
          echo "ðŸ” Waiting for services to start (max ${{ env.HEALTH_CHECK_TIMEOUT }}s)..."
          max_attempts=$((${{ env.HEALTH_CHECK_TIMEOUT }} / ${{ env.HEALTH_CHECK_INTERVAL }}))

          for i in $(seq 1 $max_attempts); do
            sleep ${{ env.HEALTH_CHECK_INTERVAL }}
            all_healthy=true
            failed_services=""
            
            for port in 8001 8007 8008 8010; do
              response=$(ssh ${{ env.DROPLET_HOST }} "curl -sf http://localhost:${port}/health 2>/dev/null" || echo "")
              status=$(echo "$response" | jq -r '.status // empty' 2>/dev/null || echo "")
              
              if [ "$status" != "healthy" ] && [ "$status" != "ok" ]; then
                all_healthy=false
                failed_services="${failed_services} ${port}"
              else
                echo "  âœ“ Port ${port}: ${status}"
              fi
            done
            
            if [ "$all_healthy" == "true" ]; then
              echo "âœ… All services healthy after $((i * ${{ env.HEALTH_CHECK_INTERVAL }})) seconds"
              exit 0
            fi
            
            echo "â³ Attempt $i/$max_attempts: Waiting for:$failed_services"
          done

          echo "âŒ Services failed to become healthy within ${{ env.HEALTH_CHECK_TIMEOUT }}s"
          echo "ðŸ“‹ Checking logs..."
          ssh ${{ env.DROPLET_HOST }} "cd ${{ env.DEPLOY_PATH }}/deploy && docker compose logs --tail=50"
          exit 1

      - name: Cleanup on failure
        if: failure()
        run: |
          ssh ${{ env.DROPLET_HOST }} "docker system prune --volumes --force"

  deploy-quick:
    name: Quick Restart
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.deploy_strategy == 'quick'

    steps:
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DROPLET_SSH_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${{ env.DROPLET_IP }} >> ~/.ssh/known_hosts

      - name: Pull latest code
        run: |
          ssh ${{ env.DROPLET_HOST }} "cd ${{ env.DEPLOY_PATH }} && git pull origin main"

      - name: Quick restart
        run: |
          ssh ${{ env.DROPLET_HOST }} "cd ${{ env.DEPLOY_PATH }}/deploy && \
            docker compose restart && \
            docker image prune -f --filter 'dangling=true'"

      - name: Wait for services and health check
        run: |
          echo "ðŸ” Waiting for services to start (max 60s for quick restart)..."
          max_attempts=12

          for i in $(seq 1 $max_attempts); do
            sleep 5
            all_healthy=true
            failed_services=""
            
            for port in 8001 8007 8008 8010; do
              response=$(ssh ${{ env.DROPLET_HOST }} "curl -sf http://localhost:${port}/health 2>/dev/null" || echo "")
              status=$(echo "$response" | jq -r '.status // empty' 2>/dev/null || echo "")
              
              if [ "$status" != "healthy" ] && [ "$status" != "ok" ]; then
                all_healthy=false
                failed_services="${failed_services} ${port}"
              else
                echo "  âœ“ Port ${port}: ${status}"
              fi
            done
            
            if [ "$all_healthy" == "true" ]; then
              echo "âœ… All services healthy after $((i * 5)) seconds"
              exit 0
            fi
            
            echo "â³ Attempt $i/$max_attempts: Waiting for:$failed_services"
          done

          echo "âŒ Services failed to become healthy within 60s"
          echo "ðŸ“‹ Checking logs..."
          ssh ${{ env.DROPLET_HOST }} "cd ${{ env.DEPLOY_PATH }}/deploy && docker compose logs --tail=50"
          exit 1

  notify:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs:
      [detect-changes, prepare-env, deploy-config, deploy-full, deploy-quick]
    if: always()

    steps:
      - name: Summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Strategy**: ${{ needs.detect-changes.outputs.deploy_strategy }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Code Changes:** ${{ needs.detect-changes.outputs.has_code_changes }}" >> $GITHUB_STEP_SUMMARY
          echo "**Config Changes:** ${{ needs.detect-changes.outputs.has_config_changes }}" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.deploy-config.result }}" == "success" ] || \
             [ "${{ needs.deploy-full.result }}" == "success" ] || \
             [ "${{ needs.deploy-quick.result }}" == "success" ]; then
            echo "âœ… **Deployment successful**" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Deployment failed**" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Trigger cleanup workflow
        if: success()
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'cleanup-docker-resources.yml',
              ref: 'main',
              inputs: {
                cleanup_type: 'standard'
              }
            });
